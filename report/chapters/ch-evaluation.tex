\SetPicSubDir{ch-Evaluation}
\SetExpSubDir{ch-Evaluation}

\chapter{Verification Examples}
\label{ch:evaluation}
\vspace{2em}

\section{Verification with abstract predicates}

Higher order programs provide better abstraction to programmers. Consider the 
\texttt{twice} function in \autoref{code:twice}. It takes a function input
\texttt{f} and an integer \texttt{x} as input and return the result of applying
the function twice to x. Here $\texttt{f}$ can be any function that takes an
integer input and return an integer output. When we specify or verify 
the function \texttt{twice}, we do not know what concrete function \texttt{f}
is. On the other hand, we expect our verification process to be modular
with respect to independent method declarations.

We propose abstract predicates as a solution. For the \texttt{twice} example, 
we universally quantify the specification with an abstract predicate
\texttt{fpure}, which is a binary relation of integers. Now we can specify
the argument \texttt{f} with a specification that the return value of \texttt{f}
and the input \texttt{a} should satisfy relation \texttt{fpure(a,res0)}. Then for the \texttt{twice} function, we can specify the postcondition with 
the composition of the binary relation \texttt{fpure}.


\begin{lstlisting}[language=Caml, mathescape=true, xleftmargin=2em, aboveskip=1em, xrightmargin=1em, numbers=left, frame = {TB}, caption={Higher order twice function}, label={code:twice} ]
let twice f x = f (f x)
(*@ declare twice(f,x)
given fpure(int,int)
requires.    { true with
                f(a) |= { true } *->:res0 {fpure(a,res0)} }
ensures[res] {EX (n:int), fpure(x,n) & fpure(n,res) } @*)
\end{lstlisting}

We show that our system is able to verify such method and specification by
listing the verification process. First, \nameref{rule:fv-method} will extract
the specification for \texttt{f} to the verification context so that it 
can be used when verifying the function body. Next, \nameref{rule:fv-app-full} 
will be applied twice, producing two anchors \texttt{res'}, \texttt{res}
satisfying \texttt{fpure(n,res')} and \texttt{fpure(res',res)}. The entailment
checker can then instantiate the existential variable \texttt{n} to be
the intermediate anchor \texttt{res'} and check the entailment holds,
which finishes the verification.

Next, we demonstrate how the specification we have verified for \texttt{twice} is used at the call site. We provide \texttt{incr} as an instance to the \texttt{twice} function, as \autoref{code:incr_twice} shows. 

Note that our system has already integrated some basic specifications for library functions such as \texttt{(+)}, which can be considered as an infix syntatic sugar for a function that takes two inputs. Therefore, the specification for \texttt{incr} is easy to verify.

The verification of \texttt{incr\_twice} can be simply done by applying \nameref{rule:fv-app-full}. Note that the specification for \texttt{twice} has an abstract predicate \texttt{fpure}, so we should instantiate it as \texttt{fpure(x,res) |= res = x + 1} to make the verification succeed. The inference of instantiating is expected to be automatically done based on the existing specification of \texttt{incr}. However, to simplify the implementation, our current system requires user to manually provide the instance when an abstract predicate should be instantiated.

\begin{lstlisting}[language=Caml, mathescape=true, xleftmargin=2em, aboveskip=1em, xrightmargin=1em, numbers=left, frame = {TB}, caption=Higher order twice function application, label=code:incr_twice]
let incr x = x + 1
(*@ declare incr(x)
requires    { true }
ensures[r]  { r = x + 1 } @*)

let incr_twice x2 = twice incr x2
(*@ declare incr_twice (x2)
 requires    { true }
 ensures[r]  { r = x2 + 2 } @*)
\end{lstlisting}

In the verification of \texttt{incr\_twice}, there are two invocations to the entailment checker. The first call takes place when using the \nameref{rule:fv-app-full}. We need to check the derivation from the precondition of \texttt{incr\_twice} to the precondition of \texttt{twice}, which involves the checking of both the pure predicate part and the specification part. The pure part is trivial, and the specification part is also straightforward since specification for argument \texttt{f} instantiated with \texttt{fpure(x,res) |= res = x + 1} is almost the same as the specification of \texttt{incr}, so the subsumption relation holds.


\section{Function as return values}

The next example shows how our system deals with function as return values. Consider use the specification of \texttt{div} to verify \texttt{div\_by\_two} in \autoref{code:div}. The forward verifier will use \nameref{rule:fv-app-par} to replace \texttt{y} with \texttt{2} in the specification of \texttt{div}, so the inferred assertion at the end of the function body will be
$$
\texttt{
true with f(x) |= \{  2 != 0 \} *->:m \{ m * 2 = x \}
}
$$

The subsumption relation between the inferred function specification and the expected specification can then be checked by the entailment checker.

\begin{lstlisting}[language=Caml, mathescape=true, xleftmargin=2em, aboveskip=1em, xrightmargin=1em, numbers=left, frame = {TB}, caption=Function as return value, label=code:div]
let div y x =  (x / y)
(*@ declare div(y, x)
requires    { ~ y = 0 }
ensures  [r]{ r * y = x } @*)

let div_by_two = (div 2)
(*@ declare div_by_two()
requires    { true }
ensures  [f]{ true with 
                f(x) |= { true } *->:m { m * 2 = x } } @*)
\end{lstlisting}

The specification \texttt{div\_by\_two} we have verified above can also be used when applied to higher order functions. Consider a similar use case of \texttt{twice} in \autoref{code:div2}. Recall that the previous example in \autoref{code:incr_twice} has the specification for \texttt{f(a)} readily in the precondition, so after normalization, the forward verifier can directly find \texttt{f} defined in the verification context, thus applying \nameref{rule:fv-var}. By contrast, here the argument \texttt{div\_by\_two} has a specification without any arguments, and the actual specification we want is hidden in the postcondition. This is why we need the rule \nameref{rule:fv-fun-eval} to deal with our nested assertion structure. After applying \nameref{rule:fv-fun-eval}, the remaining verification process is similar to that of \autoref{code:incr_twice}

\begin{lstlisting}[language=Caml, mathescape=true, xleftmargin=2em, aboveskip=1em, xrightmargin=1em, numbers=left, frame = {TB}, title=Returned function as parameter, label=code:div2]
let div_by_four x = twice div_by_two x
(*@ declare div_by_four(x)
requires    { true }
ensures  [r]{ 4 * r = x } @*)
\end{lstlisting}


\section{Recursive predicates}

Note fibP is not given here.

\begin{lstlisting}[language=Caml, mathescape=true, xleftmargin=2em, aboveskip=1em, xrightmargin=1em, numbers=left, frame = {TB}, title=Use inductive predicates to specify recursive function]
let rec fib n =
  if n = 0 then 1 else
    if n = 1 then 1 else 
      fib (n - 1) + fib (n - 2)
      
(*@ declare fib(n)
requires { 0<=n }
ensures[res] { fibP(n,res) }

pred fibP(q1:int,q2:int) |=
    q1 = 0 & q2 = 1 or  q1 = 1 & q2 = 1
or  EX (r1:int) (r2:int), q2 = r1 + r2 
      & fibP(q1 - 1,r1) & fibP(q1 - 2,r2) @*)
\end{lstlisting}



\section{Verify functions on variant types}

\begin{lstlisting}[language=Caml, mathescape=true, xleftmargin=2em, aboveskip=1em, xrightmargin=1em, numbers=left, frame = {TB}, title=Use inductive predicates to specify functions on variant types]
type list = Nil
          | Cons of (int * list)

(*@ pred LL(n:int,l:list) |= l::Nil<> & n=0
    or EX (i:int) (q:list), l::Cons<i,q> & LL(n - 1, q) @*)

let rec length lst =
(*@ declare length(lst:list)
    given (n:int)
    requires      { LL(n,lst) }
    ensures[res]   { res = n }  @*)
  match lst with
  | Nil -> 0
  | Cons (x, xs) -> 1 + length xs
\end{lstlisting}



\begin{lstlisting}[language=Caml, mathescape=true, xleftmargin=2em, aboveskip=1em, xrightmargin=1em, numbers=left, frame = {TB}, title=Use inductive predicates to specify functions on variant types]
(*@ pred LL_foldl(x,r,ys:list,fpure:int->int->int->bool)
|= ys::Nil<> & x=r
or EX (ys':list) (y:int), ys::Cons<y,ys'> & 
       LL_foldl(z,r,ys',fpure) & fpure(x,y,z)  @*)

let rec fold_left f x ys = 
(*@ declare fold_left(f:int->int->int,x:int,ys:list)
given         fpure(int,int,int), (r:int)
requires      { LL_foldl(x,r,ys,fpure) 
                   with f(x,y) |= {true} *->:r {fpure(x,y,r)} }
ensures[res]  { res = r } @*)
match ys with
| Nil -> x
| Cons (y, ys') -> fold_left f (f x y) ys'

let fold_length x y = x + 1
(*@ declare fold_length(x,y)
   requires      { true }
   ensures[res]  { res=x+1 } @*)


let length xs = fold_left fold_length 0 xs
(*@ declare length(xs:list)
   given (n:int)
   requires      { LL<n,xs> }
   ensures[res]  { res=n } @*)
\end{lstlisting}




