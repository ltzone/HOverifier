
@article{Yoshida2008,
abstract = {We introduce an extension of Hoare logic for call-by-value higher-order functions with ML-like local reference generation. Local references may be generated dynamically and exported outside their scope, may store higher-order functions and may be used to construct complex mutable data structures. This primitive is captured logically using a predicate asserting reachability of a reference name from a possibly higher-order datum and quantifiers over hidden references. We explore the logic's descriptive and reasoning power with non-trivial programming examples combining higher-order procedures and dynamically generated local state. Axioms for reachability and local invariant play a central role for reasoning about the examples. {\textcopyright} N. Yoshida, K. Honda, and M. Berger.},
author = {Yoshida, Nobuko and Honda, Kohei and Berger, Martin},
doi = {10.2168/LMCS-4(4:2)2008},
file = {:Users/ltzhou/Library/Application Support/Mendeley Desktop/Downloaded/Yoshida, Honda, Berger - 2008 - Logical reasoning for higher-order functions with local state.pdf:pdf},
issn = {18605974},
journal = {Logical Methods in Computer Science},
keywords = {Languages,Theory,Verification},
number = {4},
title = {{Logical reasoning for higher-order functions with local state}},
volume = {4},
year = {2008}
}
@article{Andrew2021Subsumption,
abstract = {The type-theoretic notions of existential abstraction, subtyping, subsumption, and intersection have useful analogues in separation-logic proofs of imperative programs. We have implemented these as an enhancement of the verified software toolchain (VST). VST is an impredicative concurrent separation logic for the C language, implemented in the Coq proof assistant, and proved sound in Coq. For machine-checked functional-correctness verification of software at scale, VST embeds its expressive program logic in dependently typed higher-order logic (CiC). Specifications and proofs in the program logic can leverage the expressiveness of CiC—so users can overcome the abstraction gaps that stand in the way of top-to-bottom verification: gaps between source code verification, compilation, and domain-specific reasoning, and between different analysis techniques or formalisms. Until now, VST has supported the specification of a program as a flat collection of function specifications (in higher-order separation logic)—one proves that each function correctly implements its specification, assuming the specifications of the functions it calls. But what if a function has more than one specification? In this work, we exploit type-theoretic concepts to structure specification interfaces for C code. This brings modularity principles of modern software engineering to concrete program verification. Previous work used representation predicates to enable data abstraction in separation logic. We go further, introducing function-specification subsumption and intersection specifications to organize the multiple specifications that a function is typically associated with. As in type theory, if ϕ is a [InlineMediaObject not available: see fulltext.] of $\psi$, that is ϕ< : $\psi$, then x: ϕ implies x: $\psi$, meaning that any function satisfying specification ϕ can be used wherever a function satisfying $\psi$ is demanded. Subsumption incorporates separation-logic framing and parameter adaptation, as well as step-indexing and specifications constructed via mixed-variance functors (needed for C's function pointers).},
author = {Beringer, Lennart and Appel, Andrew W},
doi = {10.1007/s10703-020-00353-1},
issn = {15728102},
journal = {Formal Methods in System Design},
keywords = {Foundational program verification,Intersection specifications,Separation logics,Specification subsumption},
title = {{Abstraction and subsumption in modular verification of C programs}}
}
@inproceedings{Kawaguchi2009LHDS,
abstract = {We present a refinement type-based approach for the static verification of complex data structure invariants. Our approach is based on the observation that complex data structures are typically fashioned from two elements: recursion (e.g., lists and trees), and maps (e.g., arrays and hash tables). We introduce two novel type-based mechanisms targeted towards these elements: recursive refinements and polymorphic refinements. These mechanisms automate the challenging work of generalizing and instantiating rich universal invariants by piggybacking simple refinement predicates on top of types, and carefully dividing the labor of analysis between the type system and an SMT solver [6]. Further, the mechanisms permit the use of the abstract interpretation framework of liquid type inference [22] to automatically synthesize complex invariants from simple logical qualifiers, thereby almost completely automating the verification. We have implemented our approach in DSOLVE, which uses liquid types to verify OCAML programs. We present experiments that show that our type-based approach reduces the manual annotation required to verify complex properties like sortedness, bal-ancedness, binary-search-ordering, and acyclicity by more than an order of magnitude. Copyright {\textcopyright} 2009 ACM.},
author = {Kawaguchi, Ming and Rondon, Patrick and Jhala, Ranjit},
booktitle = {Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)},
doi = {10.1145/1542476.1542510},
isbn = {9781605583921},
keywords = {Dependent types,Hindley-milner,Predicate abstraction,Type inference},
pages = {304--315},
title = {{Type-based data structure verification}},
year = {2009}
}
@article{Kleymann1999HoareAux,
abstract = {Auxiliary variables are essential for specifying programs in Hoare Logic. They are required to relate the value of variables in different states. However, the axioms and rules of Hoare Logic turn a blind eye to the role of auxiliary variables. We stipulate a new structural rule for adjusting auxiliary variables when strengthening preconditions and weakening postconditions. Courtesy of this new rule, Hoare Logic is adaptation complete, which benefits software re-use. This property is responsible for a number of improvements. Relative completeness follows uniformly from the Most General Formula property. Moreover, one can show that Hoare Logic subsumes Vienna Development Method's (VDM) operation decomposition rules in that every derivation in VDM can be naturally embedded in Hoare Logic. Furthermore, the new treatment leads to a significant simplification in the presentation for verification calculi dealing with more interesting features such as recursion.},
author = {Kleymann, Thomas},
doi = {10.1007/s001650050057},
file = {:Users/ltzhou/Library/Application Support/Mendeley Desktop/Downloaded/Kleymann - 1998 - Hoare Logic and Auxiliary Variables.pdf:pdf},
issn = {09345043},
journal = {Formal Aspects of Computing},
keywords = {Adaptation completeness,Auxiliary variables,Hoare logic,Most general formula,VDM},
number = {5},
pages = {541--566},
title = {{Hoare logic and auxiliary variables}},
volume = {11},
year = {1999}
}
@inproceedings{Vazou2014LiquidHaskell,
abstract = {SMT-based checking of refinement types for call-by-value languages is a well-studied subject. Unfortunately, the classical translation of refinement types to verification conditions is unsound under lazy evaluation. When checking an expression, such systems implicitly assume that all the free variables in the expression are bound to values. This property is trivially guaranteed by eager, but does not hold under lazy, evaluation. Thus, to be sound and precise, a refinement type system for Haskell and the corresponding verification conditions must take into account which subset of binders actually reduces to values. We present a stratified type system that labels binders as potentially diverging or not, and that (circularly) uses refinement types to verify the labeling. We have implemented our system in LIQUIDHASKELL and present an experimental evaluation of our approach on more than 10,000 lines of widely used Haskell libraries. We show that LIQUIDHASKELL is able to prove 96\% of all recursive functions terminating, while requiring a modest 1.7 lines of termination-annotations per 100 lines of code.},
author = {Vazou, Niki and Seidel, Eric L and Jhala, Ranjit and Vytiniotis, Dimitrios and Peyton-Jones, Simon},
booktitle = {ACM SIGPLAN Notices},
doi = {10.1145/2628136.2628161},
file = {:Users/ltzhou/Library/Application Support/Mendeley Desktop/Downloaded/Vazou et al. - Unknown - Refinement Types For Haskell.pdf:pdf},
isbn = {9781450328739},
issn = {15232867},
number = {9},
pages = {269--282},
title = {{Refinement types for Haskell}},
url = {http://rise4fun.com/Dafny/wVGc},
volume = {49},
year = {2014}
}
@article{Chin2012HipSleek,
abstract = {Despite their popularity and importance, pointer-based programs remain a major challenge for program verification. In recent years, separation logic has emerged as a contender for formal reasoning of pointer-based programs. Recent works have focused on specialized provers that are mostly based on fixed sets of predicates. In this paper, we propose an automated verification system for ensuring the safety of pointer-based programs, where specifications handled are concise, precise and expressive. Our approach uses user-definable predicates to allow programmers to describe a wide range of data structures with their associated shape, size and bag (multi-set) properties. To support automatic verification, we design a new entailment checking procedure that can handle well-founded predicates (that may be recursively defined) using unfold/fold reasoning. We have proven the soundness and termination of our verification system and built a prototype system to demonstrate the viability of our approach. {\textcopyright} 2011 Elsevier B.V. All rights reserved.},
author = {Chin, Wei Ngan and David, Cristina and Nguyen, Huu Hai and Qin, Shengchao},
doi = {10.1016/j.scico.2010.07.004},
file = {:Users/ltzhou/Library/Application Support/Mendeley Desktop/Downloaded/Chin et al. - 2012 - Automated verification of shape, size and bag properties via user-defined predicates in separation logic.pdf:pdf},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {Automated verification,Entailment checking,Inductive shape predicates with size and bag prope,Separation logic},
month = {8},
number = {9},
pages = {1006--1036},
publisher = {Elsevier},
title = {{Automated verification of shape, size and bag properties via user-defined predicates in separation logic}},
volume = {77},
year = {2012}
}
@article{Hoare1969,
abstract = {In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantage, both theoretical and practical, may follow from a pursuance of these topics. {\textcopyright} 1969 ACM. All rights reserved.},
author = {Hoare, C. A.R.},
doi = {10.1145/363235.363259},
issn = {15577317},
journal = {Communications of the ACM},
keywords = {axiomatic method,formal language definition,machine-independent programming,program documentation,programming language design,theory of programming' proofs of programs},
month = {10},
number = {10},
pages = {576--580},
publisher = {ACM PUB27 New York, NY, USA},
title = {{An axiomatic basis for computer programming}},
url = {https://dl.acm.org/doi/abs/10.1145/363235.363259},
volume = {12},
year = {1969}
}
@article{Rondon2008LiquidTypes,
abstract = {We present Logically Qualified Data Types, abbreviated to Liquid Types, a system that combines Hindley-Milner type inference with Predicate Abstraction to automatically infer dependent types precise enough to prove a variety of safety properties. Liquid types allow programmers to reap many of the benefits of dependent types, namely static verification of critical properties and the elimination of expensive run-time checks, without the heavy price of manual annotation. We have implemented liquid type inference in DSOLVE, which takes as input an OC AML program and a set of logical qualifiers and infers dependent types for the expressions in the OCAML program. To demonstrate the utility of our approach, we describe experiments using DSOLVE to statically verify the safety of array accesses on a set of OCAML benchmarks that were previously annotated with dependent types as part of the DML project. We show that when used in conjunction with a fixed set of array bounds checking qualifiers, DSOLVE reduces the amount of manual annotation required for proving safety from 31\% of program text to under 1\%. Copyright copy; 2008 ACM.},
author = {Rondon, Patrick M and Kawaguchi, Ming and Jhala, Ranjit},
doi = {10.1145/1379022.1375602},
file = {:Users/ltzhou/Library/Application Support/Mendeley Desktop/Downloaded/Rondon, Kawaguchi, Jhala - Unknown - Liquid Types.pdf:pdf},
isbn = {9781595938602},
issn = {15232867},
journal = {ACM SIGPLAN Notices},
keywords = {Dependent Types,Hindley-Milner,Predicate Abstraction,Type Inference},
number = {6},
pages = {159--169},
title = {{Liquid types}},
volume = {43},
year = {2008}
}
@inproceedings{Reynolds2002,
abstract = {In joint work with Peter O'Hearn and others, based on early ideas of Burstall, we have developed an extension of Hoare logic that permits reasoning about low-level imperative programs that use shared mutable data structure. The simple imperative programming language is extended with commands (not expressions) for accessing and modifying shared structures, and for explicit allocation and deallocation of storage. Assertions are extended by introducing a "separating conjunction" that asserts that its sub-formulas hold for disjoint parts of the heap, and a closely related "separating implication". Coupled with the inductive definition of predicates on abstract data structures, this extension permits the concise anal flexible description of structures with controlled sharing. In this paper, we will survey the current development of this program logic, including extensions that permit unrestricted address arithmetic, dynamically allocated arrays, and recursive procedures. We will also discuss promising future directions.},
author = {Reynolds, John C.},
booktitle = {Proceedings - Symposium on Logic in Computer Science},
doi = {10.1109/lics.2002.1029817},
issn = {10436871},
pages = {55--74},
title = {{Separation logic: A logic for shared mutable data structures}},
year = {2002}
}


@misc{OCaml,
author = {Xavier, Leroy and Damien, Doligez and Alain, Frisch and Jacques, Garrigue and Didier, R{\'{e}}my and J{\'{e}}r{\^{o}}me, Vouillon},
title = {{OCaml - The OCaml Manual}},
url = {https://ocaml.org/manual/},
urldate = {2021-11-05}
}
